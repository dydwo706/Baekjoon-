0. 문자열 표현 : '' "" """ """
   and &
   or |
   ++ -- 기호 못써
   
   "i eat %d apples", %3  _ 이렇게 편하게 작성할 수도 있엉. 값이 여러개면 %(3,4)이런식
   "one means {num } hello means {kor} yeah~" .format(kor="안녕", num="1") _ 이러면 괄호사이에 문자가 들어감.
   
   소수점 몇번째 자리까지~  _ %0.4f   
   앞 몇칸 띄우고 글자출력  _ %10s
   
   
   
   
   
1. //가 몫을 구하는 것


2. 입출력

   * input()을 해야 입력할 수 있음. 하지만 이는 문자열이기 때문에 int(input())을 해야 숫자로ㅇㅇ
     print("%d %s %d" %(1, 'str', 3))형식으로 ㅇ
   
   * print('%d%%'%a) 처럼 ''안에 %d, %f와 같이 %연산자가 쓰였으면 뒤에 또 %가 쓰일 때 %%두번 해줘야함.ex 백준4344
   
   * print()안에 "ㅁ" "ㅂ"이렇게 쓰면 ㅁㅂ로 사이에 ,를 넣으면 띄어쓰기해서 나옴.
   
   * print(end=" ") -> 다음에 print하는 내용을 다음줄로 넘기지 않고 이어서 쓰게 함
   
   ex) 별찍기
   print(' ' + '*')  같이 가운데 +를 사용하면 연속으로 출력할 수 있다.
   print(' ', '*')   같이 사용하면 공백이 두번 연속 생기기 때문에 주의!
   
  * 변수, 주소, 할당
    
    a=[1,2,3]
    b=a  -> b에 a의 주소를 할당한 것이여서 a의 값을 바꾸면 b의 값도 바뀜
    
    b=a[:]  -> b에 a의 값을 할당했기에 a의 값을 바꿔도 b의 값은 바뀌지 않음. id(a) id(b)를 출력해보면 주소가 다른 것을 확인.
    
    또 from copy import copy를 통해 라이브러리를 추가하면
    b=copy(a)하면 이 또한 a의 값을 할당한다. 대신 같은 주소를 공유하는 것이 아니라 새로운 주소에 단지 a의 값만 갖다 붙힌 것.
    
    -할당 : a,b = ('abc', 'def')
          [a,b] = ['1','2']
           a = b = '1'
           a,b=b,a 처럼 tmp를 이용한 값변환처럼 사용 가능 
3. 조건문 
   if ___:
      _____   (기본)
   elif ___ and/or ___:
      _____
   elif not ___:
      _____
   else :
      _____
   
   *조건부 표현식 : true일 때 조건을 먼저 입력해 놓고 조건식에서 false가 나오면 바꿔준다
    ㄴ a = 1 if b < 0 else 2 -> b가 음수면 a가 2가 되는 거임.
    
    
4. 함수 - 함수에 input 이나 output이 없을 수도 있다. 전자의 경우엔 def 옆에 인자가 비어있는 것이고 후자의 경우는 출력값이 none이라고 뜸. 
   def ___(인자):
       _____
   
   def ____(__,__,__):
       _____
       return _
       
   * 몇개의 인자를 넣을지 미정인 상태면 
     def sum_all (*args):
         sum =0
         for i in args:
            sum =sum+i
         return sum
     print(sum_all(1,2,3))
     이와 같이 *args라는 표현을 써서 정해지지 않은 여러 수를 입력 받을 수 있다. (굳이 args표현을 안 써도 되지만 통용되는 표현이다.)
     
     
    * keywords parameter
      
      def print_kwargs(**kwargs):
          for k in kwargs.keys():
              if (k=='name'):
                 print("당신의 이름은 :" + k)
     print(print_kwargs(name="int 조수", b="2"))    ->    dictionary 개념과 비슷하게 key와 value를 조합해서 사용하는 방법도 있다.
     
     
    * 함수의 결과 값은 하나.
     
      def func(a,b):
         return a+b, a-b, a*b
      print(func(1,2))              ->   return 값을 여러개 설정하면 출력을 튜플 형태로 한다. ex) (3,-1,2)로 나오기 떄문에 특정 값만 출력하고 싶으면 func(1,2)[1]형태로 ㄱ
      
      
    * 인자 미리 선언.
    
     인자를 예를 들어 def func(a,b=True): 와 같은 형식으로 쓴다면 함수를 호출할 때 func(1)만 해줘도 실행이 된다. 
     단 func(1, False)같이 호출하면 b는 True가 아닌 False로 입력을 받음.
     미리 선언하려면 인자들 중 마지막 자리에 넣어주기.
     
     
    * 응애 나 애기 인자.
    
      def func (a,b,c): 처럼 인자가 여러개일 경우 호출할 떄 func(a=12,c='응애',b=3)처럼 호출하면 순서 신경 안 써도.
     
     
    * 지역변수의 전역화
    
      함수 밖에서 선언된 a라는 변수를 함수 안에서도 효력이 있게 만들고 싶으면 함수 안에서 global a라고 선언 해주라!
      
      
    * 쩌는 Lambda 함수
    
      def add(a,b): return a+b 라는 함수는
      add = lambda a,b: a+b
      print(add(1,2))  로 나타낼 수 있다.
      
      또!
      
      list = [lambda a,b:a+b, lambda a,b:a-b]처럼 리스트 안에 함수를 명령할 수 있다. 원래 저 자리에 def add이런거 쓸 수 없음.
      호출도 list[0](1,2) 이런 식으로 하면 댐. 기머링
      
      
     
5. 반복문
  5-1. while ____:    -> 실행한 조건 or True
           ___
           ___  (변수에 대한 증감 조건해줘야함)
  5-2. for i in range(종료값):
          ____
       for i in reversed(range(1,7)):   ->하면 6에서 1까지 감소하는 i를 얻을 수 잇다.
          ____                    
       for i in list:
          ____
       for i in range(시작, 종료, +-증감)
          ___  
          
       a = [(1,2), (3,4), (5,6)]
       for (first, last) in a:
           print(first last)    -> 와 같이 리스트 속의 튜플을 이용할 수 도 있다.
           
       for i in range(3):
           if i>2:
              break           ->끝내기
           elif i<2:
              continue       -> 해당 위치에서 끝내고 다시 반복
           else :
              ___
              
        for i,val in enumerate(list):
            print(i,val)        하면 해당 원소의 번호와 원소값을 동시에 배출!
             
        (1)result = [x*y for x in range(2,10) for y in range(1,10)]
        (2)result = []
           for x in range(2,10):
              for y in range(1,10):
                 result.append(x*y)    -> 1번 식과 2번식은 같은 의미.
6. 리스트

x=[1,2,3]
y=['아앙', '잉', 5,6]
x+y 같은 연산 ㄱㄴ
x[1]=4 와 같이 값변환 ㄱㄴ
len(x) - 길이
sort(x) - 영구 정렬, 리턴값 none /// y=sorted(x)는 임시로 x를 정렬한 값을  y에 저장
sum(x) -  합
for n in x:
   print(n)    -> x리스트 값을 n에 담아
list[-1] 하면 맨 마지막 문자를 가져온다.

*슬라이싱_ a[:2] - 2미만 인덱스 나열
         a[2:] - 2이상 인덱스 나열
         a[::2] - 처음부터 끝까지 2칸 간격으로 나열 (a[::-1] 이건 뒤에서부터 읽ㄴ느거얌)
         ex) a=['a', 'b', 'c']
             a[0:1] = ['d','e']
             -> d,e,c
             
7. 튜플

 - 리스트랑 같음 차이점은 x =(1,2,3) 과 같이 괄호
 - 변환x
 
 
 이중배열과 같은 형태 래스끼릿!
 ex__   list1=[1,2]
        list2=[3,4]
        tuple = (list1, list2)
        print(tuple)  --->     ([1,2], [3,4]) ㅇㅋ
 
8. dictionary _ 다른 언어의 hash, map, json과 같은 역할. 

 -key를 통해서 value를 얻는다!
 
 x {
    "name" : "cho",
    0 : 20,
    1 : 30,
    }
 print(x["name"])
 print(x[0])
 print(x) 
 
 x['age'] = 3 이렇게 쓰면 값을 추가할 수 있다.
 
 *dictionary 함수들
 -keys() _ 키값만 출력
 -values() _ value들만 출력
 -items() _ 키랑 벨류 쌍으로 묶어서 전체 출력
   위 함수들은 반복문에서 range 자리에 넣을 수 있다.
 -clear() _ 초기화
 -get() _ x[1]와 같으나 없는 값을 return하면 x[5]는 에러가 뜨고 get(5)은 None을 return한다.
 
 
 
 9. 집합

 -중복x
 -순서x
 -데이터를 다룰 때 쓰임. ex_ 중복된 값이 많은 리스트를 set으로 묶고 다시 s2 = list(set(s1))같이 표현하면 중복된 값이 사라진 리스트로 변환된다.
  
 -표현 : s1 = set([1,2,3]) or {1,2,3} or set("hello") 
 
        s2 = set{3,4,5}
        
        교집합 : print(s1&s2) or print(s1.intersection(s2)) -> 3
        합집합 : print생략 s1 | s2 or s1.union(s2)
        차집합 : s1 - s2 or difference()
        추가, 여러개 추가 : add(9), update([7,8,9]) _ return X
        제거 : remove()
 
 
 10. boolean
 
    - 참과 거짓
    - "abc" : 참
      "",'' : 거짓
      [1,2] : 참
      [],(),{} : 거짓
      1 : 참
      0 : 거짓
      True : 참
      False : 거짓
      ㄴ 얘네를 조건문의 조건에 쓰면 참 거짓으로 나뉘어서 반복문 실행 가능 
 
 
 11. 파일
 
   * 생성삭제
     f = open("주소/이름.txt", 'w / r / a')  => r은 읽기모드 w은 새로쓰기 a는 파일 마지막에 내용추가
     f.close
     
     ex)
     f = open("직박구리.txt", 'w', encoding="UTF-8")    ->한글 안깨지게 하려고
     for i in range(1,5):
        data = "%d번째 줄입니다. \n" %i
        f.write(data)
     f.close
     
     
     f = open("직박구리.txt", 'r')
     while True:
       line = f.readline()                                  ** readline-> 한줄씩 읽어오는 함수
       if not line: break
       print(line)
     f.close
     
     or
     
     lines = f.readlines() 해주고 lines를 for문 돌려줘도 ㅇㅋ     ** readlines -> 리스트 형태로 가져와서 읽어보리기
     
     or
     
     data = f.read()                                        ** read -> 통째로 읽는다
     print(data)  도 ㅇㅋ
     
   * with문
   
     with open("딱다구리.txt". "w") as f:
        f.write("아무얘기나해봐")
    
     이렇게 쓰면 f.close 안해줘도 된다 이거야.
     
     
     
 99. 함수 메소드
  
   * count(a) _ 문자열 안에 a의 개수를 세
   * find(a) _ 가장 앞엥 있는 a의 위치. 없으면 -1
   * ","join("abcd") _ 괄호안의 문자를 " "안의 문자로 쪼개서 나타냄 -> a,b,c,d
   * upper() / lower() _ 대소문자로 변환
   * replace("a", "b") _ 문자열 안의 a를 b로 변환
   ** split() _ 괄호안의 문자를 기준으로 문자열을 나눈다
      ex) a="a:b:c:d"   a.split(:) -> ['a','b','c','d']
   * append() _ 추가
   * sort() _ 정렬 ㄱㄴㄷ 123 abc 순으로
   * reverse() _ 뒤집기
   * insert(1,3) _ 1번쨰 인덱스에 3을 넣어라
   * remove(1) _ 1이라는 값을 제거
   * pop() - 마지막 놈을 내보내
   * extend(1,2,3) _ 마지막에 추가
   * address.strip() _ strip()은  ex) address = ' 아 전역하고 싶다 ' 일 때 앞 뒤 공백을 없애줌
   * map(a,b)       - b에 대해 a를 진행한다 ex) x=map(int,input() ) 입력값을 int
   * round(실수,n)     - 소수점 n번째 자리까지만 표현
                    - n자리에 음수를 넣으면 정수자리에서 반올림ㄱㄴ
